directories:
  alphaloop: "/home/armin/my_programs/MG5_py_3_alphaloop_master/PLUGIN/alphaloop"
  out_dir: "/home/armin/my_programs/MG5_py_3_alphaloop_master/PLUGIN/alphaloop/LTD/amplitudes_rewrite"

form_options: # Will also put the rest of the options
  # Define the extra aguments for the compilation
  cores: 2
  extra-options:
    OPTIMITERATIONS: 1000
  OPTIMISATIONSTRATEGY: "CSEgreedy"

amplitude_options:
  integrand_per_diag: False # if true, every integrand will get its own c-routine
  # if true: the color structure per graph will be factorized: e.g. Tr[T^a T^b T^c]-Tr[T^a T^c T^b] will be treated as ``independent'' color-structure
  # if false: every structure is treated independently
  #   Example
  #  q q~ > g g:    True:     3 color-structures appear {T^a T^b T^c,T^a T^c T^b,T^a T^b T^c-T^a T^c T^b} where the last one is due to the 3g-vertex
  #                 False:    2 color-structures for all diagrams {T^a T^b T^c,T^a T^c T^b}
  color_per_graph: False
  color_less: True

amplitude:
  name: "test_integrand"
  diagram_list:
    # Alternative: path_to_diagrams for .py import
    - propagators:
        - loop_signature: [1] #k1
          outgoing_signature: [0, 0] #linear comb of INDEPENDENT outgoing momenta
          incoming_signature: [0, 0] #linear comb of incoming
          mass: "m1"
          power: 1
          name: "l1"
        - loop_signature: [1] #k1
          outgoing_signature: [0, 0] #linear comb of INDEPENDENT outgoing momenta
          incoming_signature: [1, 0] #linear comb of incoming
          mass: "m1"
          power: 1
          name: "l2"
      analytic_integrand: "1/(sp(k3,p1)+sp(k2,p1))^3*sprop(-k1, mT)*sprop(-k1 + p1, mT)*sprop(-k1 - p2, mT)*sprop(-k1 + p1 - k2, mT)*sprop(-k1 - p2 + k3, mT)*LmbToCmbSubs(k2,c1)*LmbToCmbSubs(k3,c2)*LmbToCmbSubs(k1,c3)*(1/4*pol(1,muL(-1))*pol(2,muL(-3))*ii^10*(gam(indS(1),lVec(-k1),indS(2))+deltaS(indS(1),indS(2))*mT)*(gam(indS(3),lVec(-k1+p1),indS(4))+deltaS(indS(3),indS(4))*mT)*(gam(indS(5),lVec(-k1-p2),indS(6))+deltaS(indS(5),indS(6))*mT)*(gam(indS(7),lVec(-k1+p1-k2),indS(8))+deltaS(indS(7),indS(8))*mT)*(gam(indS(9),lVec(-k1-p2+k3),indS(10))+deltaS(indS(9),indS(10))*mT)*1^2*gam(indS(4),muL(-1),indS(1))*gam(indS(2),muL(-3),indS(5))*yT^3*2^(1/2)*deltaS(indS(8),indS(3))*deltaS(indS(6),indS(9))*deltaS(indS(10),indS(7)))"
      index_shift: 4 # optional

  masses:
    mT: 1.0

  # The constants have to be real
  constants:
    yT: 0.00536501

  external_data:
    n_in: 2 # need to go
    n_out: 3 # need to go
    n_loop: 1 # need to go
    in_momenta: [[1, 0, 0, 1], [-1, 0, 0, 1]]
    out_momenta: [[0., 2.3, 0.2, 1.1], [0., 0.2, 1.3, 3.123]]
    # The following are complex valued: compenents are [Real part, Imaginary part]
    spinor_v: []
    spinor_vbar: []
    spinor_u: []
    spinor_ubar: []
    # + -
    pol:
      [
        [
          [0, 0],
          [-0.70710678118654752440084436210485, 0],
          [0, -0.70710678118654752440084436210485],
          [0, 0],
        ],
        [
          [0, 0],
          [0.70710678118654752440084436210485, 0],
          [0, 0.70710678118654752440084436210485],
          [0, 0],
        ],
      ]
    cpol: []
